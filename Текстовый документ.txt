# api_readonly.py
from flask import Flask, request, jsonify
from flask_cors import CORS
import sqlite3
from datetime import datetime, timedelta

DB_PATH = "./babybot.db"   # путь к той же базе, что использует бот

app = Flask(__name__)
CORS(app)  # на проде можно ограничить origin Vercel-доменом

def row_to_dict(cur, row):
    return {desc[0]: row[idx] for idx, desc in enumerate(cur.description)}

def q(sql, params=()):
    con = sqlite3.connect(DB_PATH, detect_types=sqlite3.PARSE_DECLTYPES)
    con.row_factory = sqlite3.Row
    cur = con.cursor()
    cur.execute(sql, params)
    rows = cur.fetchall()
    con.close()
    return [row_to_dict(cur, r) for r in rows]

@app.get("/api/user")
def get_user():
    tg_id = request.args.get("tg_id", type=int)
    if not tg_id: return jsonify({"error": "tg_id required"}), 400
    # Подстрой под свои таблицы: примерные поля
    rows = q("""
        SELECT u.id, u.tg_id, u.name, u.baby_name, u.baby_birthdate
        FROM users u WHERE u.tg_id = ?
        """, (tg_id,))
    return jsonify(rows[0] if rows else {})

@app.get("/api/feedings")
def get_feedings():
    tg_id = request.args.get("tg_id", type=int)
    date_str = request.args.get("date")  # YYYY-MM-DD
    if not (tg_id and date_str): return jsonify({"error": "tg_id and date required"}), 400
    start = f"{date_str} 00:00:00"
    end = f"{date_str} 23:59:59"
    rows = q("""
        SELECT id, user_id, timestamp, note, side, volume_ml
        FROM feedings
        WHERE user_id = (SELECT id FROM users WHERE tg_id = ?)
          AND timestamp BETWEEN ? AND ?
        ORDER BY timestamp ASC
    """, (tg_id, start, end))
    return jsonify(rows)

@app.get("/api/diapers")
def get_diapers():
    tg_id = request.args.get("tg_id", type=int)
    date_str = request.args.get("date")
    if not (tg_id and date_str): return jsonify({"error": "tg_id and date required"}), 400
    start = f"{date_str} 00:00:00"
    end = f"{date_str} 23:59:59"
    rows = q("""
        SELECT id, user_id, timestamp, type  -- type: wet/dirty/mixed
        FROM diapers
        WHERE user_id = (SELECT id FROM users WHERE tg_id = ?)
          AND timestamp BETWEEN ? AND ?
        ORDER BY timestamp ASC
    """, (tg_id, start, end))
    return jsonify(rows)

@app.get("/api/stats")
def get_stats():
    tg_id = request.args.get("tg_id", type=int)
    days = request.args.get("days", default=7, type=int)
    if not tg_id: return jsonify({"error": "tg_id required"}), 400
    since = (datetime.utcnow() - timedelta(days=days)).strftime("%Y-%m-%d %H:%M:%S")
    feed_count = q("""
      SELECT COUNT(*) AS c FROM feedings
      WHERE user_id = (SELECT id FROM users WHERE tg_id = ?) AND timestamp >= ?
    """, (tg_id, since))[0]["c"]
    diaper_count = q("""
      SELECT COUNT(*) AS c FROM diapers
      WHERE user_id = (SELECT id FROM users WHERE tg_id = ?) AND timestamp >= ?
    """, (tg_id, since))[0]["c"]
    return jsonify({"days": days, "feedings": feed_count, "diapers": diaper_count})

if __name__ == "__main__":
    # запусти на отдельном порту, чтобы не мешать боту
    app.run(host="0.0.0.0", port=10801)
